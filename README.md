# Trajectory 弹道轨迹
 2019 SCU-CS 研究与开发实战课程作业   
 一个模仿 __4399弹弹堂__ 与 __TNT弹道轨迹__ 的2D游戏, 使用 `EasyX` 与 `Lua`  完成  
 除了以上两个, 还要感谢以下开源库的作者, 没有他们, 这个游戏只会存在于想象里
 - [json](https://github.com/nlohmann/json) : JSON for modern C++
 - [libhv](https://github.com/ithewei/libhv) : event-loop with non-blocking IO and timer
 - [sol2](https://github.com/ThePhD/sol2) : C++ library binding for Lua
 # 进度记录(~~交作业用~~)
 20-08-30: 创建项目  
 20-09-01: 开发环境配置完成, 外部依赖可以正常使用

 # 目录结构
 ~~~
    Trajectory
        |- BattleServer     VS2019 Project
        |- Client           VS2019 Project
        |- header           
            |- battle.h         战斗服务器头文件
            |- client.h         客户端头文件
            |- ...              第三方库头文件
        |- src
            |- battle           战斗服务器
                |- main.cpp
                |- 
            |- client           客户端
                |- main.cpp 
                |- 
        |- lib              第三方库依赖
            |- ...
        |- resorce
            |- paint            动画
                |- 
            |- sound            音效
                |-
            |- script           脚本文件
                |-
        |- sercfg.lua       战斗服务器配置文件
        |- clicfg.lua       客户端配置文件
                
 ~~~

 # 开发环境搭建
 依次按照如下步骤安装， 默认使用 VS2019 
 - 使用官网自动安装程序安装 EazyX  
 [EazyX 官网地址](https://easyx.cn/)  
 [EazyX 文档地址](https://docs.easyx.cn/zh-cn/intro)   
 - 下载 Lua 源代码, 并放置到 VS2019 的 `include` 目录下  
 [Lua](https://github.com/lua/lua)  
 例如, 我的目录结构是

 ~~~
    ..\Microsoft Visual Studio\2019\Community\VC\Auxiliary\VS\include  
                                                                |- easyx.h
                                                                |- graphics.h                
                                                                |- lua.h
                                                                |- luaxlib.h
                                                                ...
 ~~~  
 
 达到这样的最终效果即可  ~~总不会这也需要教吧~~  
 在任何 cpp 文件中, 这样的语句
 ~~~
    #include <lua.h>
 ~~~
 
 或是
 
 ~~~
    #include <easyx.h>
 ~~~   
 将不会报错  
 - 从 github 上 clone 该项目到本地  
 使用 `.sln` 文件打开解决方案, 确保 `Client` 与 `BattleServer` 两个项目中的 `项目->属性` 页中  
 `c/c++ -> 预处理器 -> 输入` 中存在 `HV_STATICLIB` 宏 (引入第三方库)  
 `c/c++ -> 链接器 -> 输入 -> 附加依赖项` 中包含了 `Trajectory\lib` 目录下的所有 `lib` 文件  
 ~~`c/c++ -> 链接器 -> 输入 -> 忽略指定默认库`  中包含了 `msvcrt.lib`~~

到这里, 开发环境搭建完成, 编译运行测试程序来测试第三方库能否正常使用

# Architect 
## 组成 
 由三个部分组成
 - Client.exe  客户端    
 部署在玩家电脑上, 采集用户输入和绘制画面 ~~主要用来交作业~~
 - BattleServer.exe 战斗服务器  
 ~~因为云服务器负载快满了~~ 部署在玩家电脑上, 单独运行, 负责战斗房间中的弹道/伤害计算   
 - LoginServer.a 登陆服务器  
 ~~不得不~~ 部署在服务器上, 用于游戏大厅中玩家的登录/加入房间, 以及分配战斗服务器

 ## 通信
 服务器与客户端间的通信格式均为 `JSON`  
 各个字段定义参见 `PROTO.md`

 # 实现思路
 ~~~
     我想到了一个绝妙的点子, 可是这地方太...这里竟然写的下?     
                                                                                引自<<作者墓碑记>>
 ~~~
 
 ## 客户端
 客户端需要三个线程
 - 通信线程 IO
 - 工作线程 W
 - 绘制线程 R 
 
 ### 绘制线程 R (文中的 `渲染` 也表达绘制图像的意思)  
  
 ~~~
    显然单独一个渲染线程在绘制大量小图案时候, 需要保存各个小图案的当前绘制状态, 我猜实现起来很困难, 于是直接用 `std::async` 异步跨线程渲染图案, 并且测试效果很好.   
    
 注: 跨线程: 这里指的是其他线程干了本该渲染线程干的事情, 而不是真的跨线程. 
 ~~~
 以上是我废弃的第一个方案.  
 因为 `std::async` 函数会在返回的 `std::future` 对象析构时阻塞当前线程, 而且为了达到异步效果选择的 `std::launch::async` 其本质上是新开一个线程执行任务,  总不能为每一个临时绘制的图案都开一个新的线程吧, 那我要是同时画五十个图案怎么办?
 
 ~~~
    仿照 future/promise 模型的做法, 保存每一个渲染任务的终止条件 (可以理解成 future ), 在渲染线程中轮询每一个终止条件, 只要其尚未就绪, 那么就执行对应的渲染任务. 而一旦 future 就绪了(对应终止条件成立), 那么久将其从渲染线程中去除.
 ~~~ 

 以上是我废弃的第二个方案.   
 除了我不会写轮询 future 的调度器外(后来我意识到本就不用写调度器, 因为每一个终止条件本身就是个用于触发的函数), 这套办法最终的效果是把一个渲染任务在每一帧都执行一遍, 无法实现我想要的动画效果.   


 最终方案的一半来自于和队友的一次闲聊.
 ~~~
    "人的视觉暂留时间有多久? 30ms?", 在百无聊赖的<软件工程>课上, 我这样问我的队友.
    "嗯..., 你当30ms就行."
    这数字比我想得要大, 也就是说游戏的 FPS 控制在 1000 // 30 = 33 帧/s 就足够使用了. 但我还是有点追求的, FPS 最低要到60.
    "那按照 1s 绘制 60 帧的速度, 游戏十五分钟总共需要 54'000 帧, 用 uint_64 给帧计数是可以的, 即使 FPS 翻倍也不会溢出"
    那么, 每一个渲染任务的在当前帧的渲染动作都可以作为帧计数(也包括渲染的位置)的函数. 从实现的角度说, 如果将一个渲染任务, 例如在一个在屏幕中央不断增大的圆圈, 或者一个逐渐伸长的直线, 作为一个函数, 那么在每一帧调用这个函数都将会产生不同的效果. 而不是简单的在触发这个动画的帧里调用一次, 期待着他能在接下来的几十帧里能一边正确的画出新图案一边清除掉自己的旧图案.
    这样一来, 每个渲染任务的状态都被保存在函数内部不会扩散到线程中, 同时又能实现动画效果, 最重要的是, 就算没有闭包, C++ 仍然可以通过函数内 static 变量来实现. 
    "异步跨线程渲染gg了, 但我们有新的办法解决, 我准备叫它额..."
    "!@#$%^&*\", 他说了些什么打断了我, 但我没听清. 而且他说完就回到了平时那种面无表情的状态, 我也就没说下去.
 ~~~
 最终方案的另一半是说, 虽然C++函数内静态变量能够模拟闭包(closure), 但问题是不能同时存在两个相同的渲染任务, 比如同时在两个角落渲染逐渐增大的圆圈, 这样会出现数据竞争(data race)使得函数行为失控(当然运气够好就没事), 于是得引入lua脚本解决这个问题.  
 渲染任务的这种行为, 就像是(也确实是) 反复调用同一个函数, 但拿到的返回值却不相同, 这种模式恰好可以用lua的协程来实现, 而且 ~~我熟悉lua脚本开发~~ lua 做 C++ 游戏脚本的好处就不需要我多说了. 于是项目中就多了 sol 的依赖.

 注: 上文中提到的关于C++函数内静态变量模拟闭包在多个调用的情况下, 运气够好就不会失控是错的, 不管运气多好都不行. 因为用于存储状态的变量只有一组, 后一个调用的函数会延续上一次调用时候的状态. 但在其他大部分 data race 的情况下, 运气好真的没事. 顺带一提, 这次故事的后续是, 他在下课后告诉我, 我没听清的那句话是 "助教老师就坐在你的左边". 作为回应, 我告诉他说, 这个东西的名字叫"协程渲染"

