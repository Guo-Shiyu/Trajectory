# 如何绘制图像
 注: 因为我个人的表达习惯, 文中所有的 '渲染' 都表达 '绘制' 的含义
 ~~~
    显然单独一个渲染线程在绘制大量动态小图案时候, 需要保存各个小图案的当前绘制状态, 我猜实现起来很困难, 于是直接用 `std::async` 异步跨线程渲染图案, 并且测试效果很好.   
    
 注: 跨线程: 这里指的是其他线程干了本该渲染线程干的事情, 而不是真的跨线程. 
 ~~~
 以上是我废弃的第一个方案.  
 因为 `std::async` 函数会在返回的 `std::future` 对象析构时阻塞当前线程, 而且为了达到异步效果选择的 `std::launch::async` 其本质上是新开一个线程执行任务,  总不能为每一个临时绘制的图案都开一个新的线程吧, 那我要是同时画五十个图案怎么办?
 
 ~~~
    仿照 future/promise 模型的做法, 保存每一个渲染任务的终止条件 (可以理解成 future ), 在渲染线程中轮询每一个终止条件, 只要其尚未就绪, 那么就执行对应的渲染任务. 而一旦 future 就绪了(对应终止条件成立), 那么就将其从渲染线程中去除.
 ~~~ 

 以上是我废弃的第二个方案.   
 除了我不会写轮询 future 的调度器外(后来我意识到本就不用写调度器, 因为每一个终止条件本身就是个用于触发的函数), 这套办法最终的效果是把一个渲染任务在每一帧都执行一遍, 无法实现我想要的动画效果.   


 最终方案的一半来自于和舍友的一次闲聊.
 ~~~
    "人的视觉暂留时间有多久? 30ms?", 在百无聊赖的<软件工程>课上, 我这样问我的队友.
    "嗯..., 你当30ms就行."
    这数字比我想得要大, 也就是说游戏的 FPS 控制在 1000 // 30 = 33 帧/s 就足够使用了. 但我还是有点追求的, FPS 最低要到60.
    "那按照 1s 绘制 60 帧的速度, 游戏十五分钟总共需要 54'000 帧, 用 uint_64 给帧计数是可以的, 即使 FPS 翻倍也不会溢出"
    那么, 每一个渲染任务的在当前帧的渲染动作都可以作为帧计数(也包括渲染的位置)的函数. 从实现的角度说, 如果将一个渲染任务, 例如在一个在屏幕中央不断增大的圆圈, 或者一个逐渐伸长的直线, 作为一个函数, 那么在每一帧调用这个函数都将会产生不同的效果. 而不是简单的在触发这个动画的帧里调用一次, 期待着他能在接下来的几十帧里能一边正确的画出新图案一边清除掉自己的旧图案.
    这样一来, 每个渲染任务的状态都被保存在函数内部不会扩散到线程中, 同时又能实现动画效果, 最重要的是, 就算没有闭包, C++ 仍然可以通过函数内 static 变量来实现. 
    "异步跨线程渲染gg了, 但我们有新的办法解决, 我准备叫它额..."
    "!@#$%^&*\", 他说了些什么打断了我, 但我没听清. 而且他说完就回到了平时那种面无表情的状态, 我也就没说下去.
 ~~~

 最终方案的另一半是, 虽然C++函数内静态变量能够模拟闭包(closure), 但问题是不能同时存在两个相同的渲染任务, 比如同时在两个角落渲染逐渐增大的圆圈, 这样会出现(并非严格意义上的)数据竞争(data race)使得函数行为失控(当然运气够好就没事), 于是得引入lua脚本解决这个问题.  
 渲染任务的这种行为, 就像是(也确实是) 反复调用同一个函数, 但拿到的返回值却不相同, 这种模式恰好可以用lua的协程来实现, 而且 ~~我熟悉lua脚本开发~~ lua 做 C++ 游戏脚本的好处就不需要我多说了. 于是项目中就多了 sol 的依赖.

 注: 上文中提到的关于C++函数内静态变量模拟闭包在多个调用的情况下, 运气够好就不会失控是错的, 不管运气多好都不行. 因为用于存储状态的变量只有一组, 后一次调用的函数会延续上一次调用时候的状态. 而如果是 带有初始化性质的调用则会覆盖掉上一次调用状态, 但在其他大部分 data race 的情况下, 运气好真的没事. 
 

 顺带一提, 这次故事的后续是, 他在下课后告诉我, 我没听清的那句话是 "助教老师就坐在你的左边". 而我不想谈论这种点背的事情, 就告诉他说, 这个东西的名字叫"协程渲染"

# 协程渲染的实现方法
 我虽然叫这个东西协程渲染, 实际上还是同步串行渲染, 渲染逻辑交替在 cpp 与 lua 层面执行, 只不过 lua 层有自己的变量来控制函数的状态进而控制渲染逻辑. 我后来想了几天, 这应该叫生成器渲染(generator render )  
 一个 python 自然数生成器的例子 
 ~~~ python
    def nature_number_gen():
        step = 0
        while true:
            yield step
            step = step + 1
 ~~~

 那么, 我们每一帧的渲染流程是:   
 - 根据游戏进行的状态, 在 lua 中创建一些 coroutine 函数, 并将 coroutine 注册到 cpp 的渲染任务队列中  
 - cpp 绘制基础图案, 例如不变的背景
 - 依次渲染任务队列中的协程函数, 如果协程函数执行完毕, 那么就清除这个任务
 - 根据该帧已经消耗的执行时间和设置的 FPS 来决定 sleep 时间
 - 下一帧   
   
 实际上, 第一步未必要在渲染线程中进行, 也可以在其他线程中进行, 例如网络 io 线程收到了来自服务器的消息, 要求在一个坐标上绘制一次爆炸效果, 那么就由 io 线程进行渲染任务注册, 也就是说, 这是个异步动作.  
 
 渲染线程只重复这个循环的好处是可以保证渲染线程只负责渲染, 无需关心其他事情, ~~不管其他线程是死是活都~~能够保证帧数
 
 
 