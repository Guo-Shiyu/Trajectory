# 写在之前
 -- 自为序

Trajectory 参考自`TNT弹道轨迹` 和 `4399弹弹堂`两款游戏。从小学开始，直到高一，每年寒暑假我都和朋友开黑玩这个游戏， 花了大把的时间研究弹道、距离与角度的关系。当课设老师要求我们使用 C++ 和一个叫 EasyX 的绘图库来完成一款游戏时， 但我只用了十分钟就决定了这个选题。不仅是因为自己喜欢和了解这个游戏， 也是因为觉得自己的编码能力到了一个瓶颈，如果不沉下心来做一个大的东西，很难取得大的进步了。

思考了一天的可行性和设计思路之后，我还决定额外加上服务端部分，以支持多人在线对战。实现这个目标付出的代价也不过是将对局信息逻辑和用户输入逻辑分开处理，对应在代码上也只是网络通信的一套协议和更多的类而已。而物理成本上的服务器并不难解决。  

虽然我有一个自认为较为不错的 C++ 语言基础， 也曾经阅读过简单小游戏的源码， 并亲自完成过多人在线聊天室， 但内心对于能否驾驭一个这样大的工程还是充满了疑问。思考了几天之后， 我最终被内心中不知名的力量说服，决定挑战自己。  

一个朋友曾告诉我说，刻意给读者留下伏笔不是一个 wise choice。但我还是决定等到这个系列的最后一篇时，再说明我那一刻的想法。在此之前，我都只在这个系列记录自己在开发过程中思路的变化过程。我认为这是一件好的事情。最为重要意义就是能追根溯源到每一个灵感从产生到作用于项目的这个过程。用一个动漫人物的话来解释，这样做的「剑意是连续不断的」。  

在自己的编码过程中，一个灵感的落地，通常都是先从一个小的原型草案开始验证，deemo 成功后再应用到项目中。再者，即便是已经应用的 idea 也常常由于有了更好的方案或者由于被改进而重写。因此，这个系列的文章都会是那些经过了测试和几轮改进后能够称之为 stable 的方案，所以在进度上，文章中内容应该不那么及时，也有可能因为后续改动而与实际代码有些出入。总之，我觉得灵感本身比灵感如何变成代码更有趣，因此各位读者不要对文章中代码准确无误抱有太高的期望，但我会尽量避免这一情况。

最后，在我写完这个系列的尾声之前（也就是写下 ‘欢迎体验’ 之前），我不想跟任何人谈论涉及到这个游戏或者这一系列日志的内容，因为它也额外寄托了一些特殊的情感。在自己拥有正视内心的勇气之前，还是安静地修炼更好 ~~，同时也不想破坏了自己行动派的形象， 而如果我本就没有这样的形象的话，那也别阻碍我塑造这样的一个形象~~。


# Architect Overview    
 -- 客户端-登录服务器-战斗服务器  
 
在大一下学期，彼时的我接触编程尚不足一年，我陷入到 ‘如何写出一个联网程序’ 的困惑中。 现在看来， 想要解决这个问题对于当时的我实在是难于登天。 我不仅不懂得任何理论或者实践知识， 也完全不知道该如何下手来开始解决这个问题。 就像是摸黑来到一个陌生的大楼， 连一层的大厅都没搞清楚在哪， 何谈找到二楼通向三楼的楼梯。 以至于我茫然的在搜索引擎上搜索「计算机网络」「计算机联网程序」关键字， 得到了一堆又一堆的教学材料， 挣扎在一知半解的、稀奇古怪的专有名词中。 如此过了一个月之后， 才有一位大三学长猜指明了方向：你应该去搜索套接字 socket。 从那之后，我才终于能够开始磕磕绊绊的网络编程的实践。 又经过了半年， 我才写出了第一个正常运行的，基于UDP的多人网络聊天室。 后来，一个外校同学只用200块RMB就买走了我十二个小时的劳动成果。 

鲁莽的初学者的故事权当起兴， 现在来说明我想要解决的问题。

首先我先下一个结论，抛出两个我自己想出的概念：「输入流同步」和「状态同步」。

以 CS：GO 举例， 当一个玩家按下CTRL的时候，客户端将这个信息报告给服务器，然后服务器将其广播给所有人：玩家 xxx 按下了CTRL， 然后各自的客户端开始处理人物模型按下空格的逻辑， 可能是将人物模型从站立修改为蹲下， 也可能是碰撞盒的形状改变等等。  

另一种情况是， 当一个玩家按下空格，本地报告服务器我已经变更人物状态到 蹲下， 然后服务器广播给所有人：玩家xxx的状态变为蹲下。然后各自的客户端开始处理人物状态处于蹲下的逻辑。 

前者的问题是，处理按下CTRL键的逻辑同时发生在所有玩家的客户端中， 是没有必要的数据同步。 如果有人将键位设置改变了，或者有人修改了客户端的数据（使用修改器/外挂等），让蹲下动作的处理逻辑与趴下相同， 那么由于处理结果不同而带来的麻烦事就多了。换言之，输入流同步会引发数据冗余带来的一致性问题， 或者说， 该由客户端处理的逻辑就不要交给服务端。 客户端只是用户键鼠IO的过滤器， 服务器是真正处理逻辑的部分， 不需要关心从键鼠IO还是从手柄IO的细节。

实际上， 在FPS游戏中， 处理输入逻辑远比我说的要复杂的多。其它类型的游戏比如MOBA也更为复杂，甚至有帧同步的说法。 但对于我想做的一个简单的回合制游戏来说，状态同步就足够使用了。 对于每一个自己的回合， 客户端只需要上传攻击的角度和力度就足够了， 对于每一个不是自己的回合， 客户端只要听从服务器的指示， 更新玩家位置和播放各种动画即可。  

从实际的角度出发， 我的云服务器只有 1核和1G内存，这样拮据的算力还是不要承担战斗服务器的职能好了。于是， 玩家客户端运行于Windows平台处理用户IO， 登陆服务器挂载在云服务器上用来统计游戏大厅中的信息和分配房间到战斗服务器并校验本地各种资源文件， 战斗服务器不在乎平台，只处理对局内的逻辑， 且运行逻辑也受到登陆服务器控制（通过脚本文件的方式）。这样三权分立，就是整个项目的架构概览了，只是... 我要实现的通信协议就有三套了， 工作量陡然上升。  

考虑到作业完成的关键在于游戏逻辑， 实现过于麻烦的ui只能说是锦上添花，~~而且我也不想用 C++ 从按钮类开始重写一套事件驱动的框架~~因此我打算在游戏大厅及之前的操作都使用命令行交互，减轻工作量。从某种意义上说， 这是在解决当前阶段的主要矛盾同时忽视了次要矛盾。

# 客户端三线程模型
 -- 白手起家，但不是手无寸铁  

在学完大学课程安排的 C 之后，刚刚开始学习 C++ 中 ‘类’ 这个概念的时候，我偶然读到一本名叫 __《Windows游戏编程》__（罗林 著） 的书。印象中那本书中从最基础的绘图开始，介绍了非阻塞式读取用户输入（也可能是先介绍了后者），到最后逐步构建起几个简单的小游戏，像《打砖块》与《飞机大战》等。受限于当时能力与认知的不足，在草读了一遍全书之后，我只记下了以下两件事情：

+ 书上最后一个例子是实现《挖地小子》，让刚刚入门编程的我大为震撼。  
在小学时，我曾经乐此不疲的在 4399 上玩这个网页游戏。当发现每次通过了第一关之后都会卡死的时候，我改变目标为不杀死boss，挖空所有的方块，但努力了几个小时之后就疲倦了，从此也在没玩过这个游戏。 

+ 一个游戏就是一个死循环，重复着读入用户操作并将操作反映到屏幕的动画上的过程。 
~~这个总结应当在前几章就出现了，否则我根本没有足够的耐心读到。~~   
我还记得大概的代码是这样的 

~~~ C
int main()
{
    while(true)
    {
        if (_kbhit())   // 有键盘敲击
        {
            if(char c = _getch())       // 读取到按键键码
            {
                switch(c)               // 根据键码做处理
                {
                    case VK_UP: ...     // 上
                    case VK_DOWN: ...   // 下
                    ...            
                }
            }
        }
        draw();         // 绘制一帧图像
        sleep(20);      // 控制帧数
    }
}
~~~  

当然了，对于这个项目有主要帮助的只有第二点。

除此之外，另一个对这个项目有帮助的经历是：我曾经在 `ege` （一个与 `exsyx` 相仿的 C/C++ 绘图库）的官方群中潜水过一年，围观他们讨论各种技术问题~~和吹水~~。这让我也了解了各种绘图API的使用和常见的桌面游戏开发问题解决方案和开发思路，虽然我从没使用过 ege 这个库也没写过任何一行与绘图有关的代码。  

夏安在， 我完成了项目的渲染线程的逻辑，再回顾当时，后者减少了我花费在查阅 easyx 库函数文档的时间，而所有客户端的设计模型都是从前者，这个简陋的循环的基础上不断改进得到的。从产品的角度讲这当然是经过了不断地迭代最终得到的精粹， 可惜从开发者的角度讲， 这意味着我在Design Refine这件事情上付出了太多的精力。用中文的话说， 走了不少弯路。

从前文的代码中，可以看出客户端的逻辑就是 io-draw 循环，